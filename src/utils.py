# Utility functions for NeurIPS - Open Polymer Prediction 2025\n\ndef weighted_mae(y_true, y_pred, value_ranges, n_available):\n    \"\"\"\n    Compute the competition's weighted MAE (wMAE).\n    Args:\n        y_true: np.ndarray, shape (n_samples, n_targets)\n        y_pred: np.ndarray, shape (n_samples, n_targets)\n        value_ranges: np.ndarray, shape (n_targets,) - estimated value range for each property\n        n_available: np.ndarray, shape (n_targets,) - number of available values for each property\n    Returns:\n        float: weighted MAE\n    \"\"\"\n    T = len(value_ranges)\n    # Calculate weights\n    inv_sqrt = 1 / np.sqrt(n_available)\n    scale_norm = 1 / value_ranges\n    raw_weights = inv_sqrt * scale_norm\n    weights = raw_weights / raw_weights.sum() * T\n    # Calculate normalized MAE for each property\n    norm_mae = np.abs(y_true - y_pred) / value_ranges\n    wmae = (norm_mae * weights).mean()\n    return wmae\n\ndef smiles_to_features(smiles, n_bits=128):\n    \"\"\"\n    Convert a SMILES string to a feature vector of RDKit descriptors and Morgan fingerprint.\n    Returns a 1D numpy array.\n    \"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return np.full(8 + n_bits, np.nan)\n    descs = [\n        Descriptors.MolWt(mol),\n        Descriptors.MolLogP(mol),\n        Descriptors.NumRotatableBonds(mol),\n        Descriptors.TPSA(mol),\n        Descriptors.NumHDonors(mol),\n        Descriptors.NumHAcceptors(mol),\n        Descriptors.HeavyAtomCount(mol),\n        Descriptors.RingCount(mol),\n    ]\n    fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=n_bits)\n    fp_arr = np.array(fp)\n    return np.concatenate([descs, fp_arr]) 